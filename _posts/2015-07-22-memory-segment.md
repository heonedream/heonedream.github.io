---
title: 进程的地址空间：TEXT，DATA，BSS，HEAP，STACK
tags: 栈空间 堆空间 内存 全局变量 动态内存 虚拟内存 静态变量
---

现代操作系统对每个进程都分配了完整的虚拟内存地址空间。进程会把整个地址空间分成多个区间来使用。
程序员最为熟悉的两个区间莫过于**堆**和**栈**。然而还有其他的内存区间来存储代码、静态、全局变量等等。
本文来总结一下这些内存区间到底存的是哪些东西。先看图：

![memory segments@2x](/assets/img/blog/memory.png)

> 图片来源： <http://www.sw-at.com/blog/2011/03/23/where-does-code-execute-process-address-space-code-gvar-bss-heap-stack/>

<!--more-->

虚拟内存技术使得每个进程都可以独占整个内存空间，地址从零开始，直到内存上限。
每个进程都将这部分空间（从低地址到高地址）分为六个部分：

1. TEXT段：整个程序的代码，以及所有的常量。这部分内存是是固定大小的，只读的。
2. DATA段，又称GVAR：初始化为非零值的全局变量。
3. BSS段：初始化为0或未初始化的全局变量和静态变量。
4. HEAP（堆空间）：动态内存区域，使用`malloc`或`new`申请的内存。
5. 未使用的内存。
6. STACK（栈空间）：局部变量、参数、返回值都存在这里，函数调用开始会参数入栈、局部变量入栈；调用结束依次出栈。

其中堆空间和栈空间的大小是可变的，堆空间从下往上生长，栈空间从上往下生长。

由于常量存储在TEXT段中，所有对常量的赋值都将产生`segment fault`异常。

可以认为BSS段中的所有字节都是0。因为未初始化的全局变量、静态变量都在BSS段中，
所以它们都会被初始化为0，同时类的成员变量也会被初始化为0，但编译器不保证局部变量的初始化。

上面说栈（STACK）是从上到下（高地址到低地址）分配的，而且我们知道，
函数的局部变量的空间是在进入函数体后才分配的，在栈空间里。来个例子来看看吧！

```cpp
int main(){
    char a=0, b=0;
    int *p = (int*)&b;
    *p = 258;
    printf("%d %d", a, b);
    return 0;
}
```

输出是

```cpp
1 2
```

`a`, `b`属于局部变量，存储在栈空间中，先分配`a`的地址，再分配`b`的地址。因为栈是从上往下生长的，所以`b`的地址比`a`低一个字节。
然后对`b`的地址进行赋值258（`int`是4字节，十六进制表示是`0x00 00 01 02`）。最后1字节`0x02`赋值给了`b`，接下来1字节`0x01`赋值给了`a`。

> 上述结果和CPU端模式也有关系！我的CPU是小端字节序的~ 低位存的是低字节。

